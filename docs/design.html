<!DOCTYPE HTML>
<!--
    Escape Velocity by HTML5 UP
    html5up.net | @ajlkn
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
        <title>Overbuilt and Underpaid</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
        <link rel="stylesheet" href="assets/css/main.css" />
        <!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
        <link rel="stylesheet" href="assets/highlight/styles/monokai-sublime.css">
        <script src="assets/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body class="homepage">
        <div id="page-wrapper">

            <!-- Header -->
                <div id="header-wrapper" class="wrapper">
                    <div id="header">

                        <!-- Logo -->
                            <div id="logo">
                                <h1><a href="index.html">Robot Design</a></h1>
                                <p>ECE 3400 Team 2 Fall 2017</p>
                            </div>

                        <!-- Nav -->
                            <nav id="nav">
                                <ul>
                                    <li class="current"><a href="index.html">Home</a></li>
                                    <li>
                                        <a href="#">Labs</a>
                                        <ul>
                                            <li><a href="lab1.html">Lab 1</a></li>
                                            <li><a href="lab2.html">Lab 2</a></li>
                                            <li><a href="lab3.html">Lab 3</a></li>
                                            <li><a href="lab4.html">Lab 4</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <a href="#">Milestones</a>
                                        <ul>
                                            <li><a href="milestone1.html">Milestone 1</a></li>
                                            <li><a href="milestone2.html">Milestone 2</a></li>
                                            <li><a href="milestone3.html">Milestone 3</a></li>
                                            <li><a href="milestone4.html">Milestone 4</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="info.html">Team Info</a></li>
                                    <li><a href="minutes.html">Meeting Minutes</a></li>
                                    <li>
                                        <a href="#">Robot Design & Cost</a>
                                        <ul>
                                            <li><a href="design.html">Robot Design</a></li>
                                            <li><a href="cost.html">Robot Cost</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="ethics.html">Ethics</a></li>
                                </ul>
                            </nav>
                    
                    </div>
                </div>
                
                <div id="intro-wrapper" class="wrapper style3">
                    <div class="title">Introduction</div>
                    <section id="intro" class="container">
                        <header class="style1">
                            <h2>Goal</h2>
                            <p>
                                
                            </p>
                        </header>
                    </section>
                    </div>
                
                <div id="intro-wrapper" class="wrapper style1">
                    <div class="title">Movement</div>
                    <section id="intro" class="container">
                        <header class="style1">
                                <h2>Robot Setup</h2>
                            </header>
                            <p>
                                The final version of our robot included the following components:
                                <center>
                                <ul> 
                                    <li>2 Continous Rotation Servos attached to the two wheels</li>
                                    <li>4 line Sensors </li>
                                    <li>3 short range IR Wall Sensors</li>
                                    <li>3 IR Treasure Sensors</li>
                                    <li>1 Arduino Uno</li>
                                    <li>1 Microphone</li>
                                    <li>1 Eight to One Multiplexer</li>
                                    <li>1 Push Button</li>
                                    <li>1 Radio</li>
                                    <li>1 5V Power Bank</li>

                                </ul>
                                </center>
                                The Arduino is the microcontroller that takes in data from all of the sensors, processes our algorithm and controls the servos that move our robot. The microphone and push button are used to start the robot. Either a specific tone is heard by the microphone or the button is pressed to begin the maze mapping. The multiplexer is used to select between 7 different signals: the 3 wall sensors, the 3 treasure sensors or the microphone. The radio is used to communicate the maze information to the base station which displays the maze. Every sensor, servo and the microcontroller is powered by the power bank.
                                </p>
                                <p>

                                The four line sensors, used to line follow, were placed just a few centimeters above the ground in the front of our robot. Below is a picture of the labeling each of the line sensors.
                                <center>
                                <a href="#" class="image featured">
                                    <img src="assets/images/milestone1_line_sensors.jpg" alt="" style="width:512px;"/>
                                </a>
                                </center>

                                The middle two, reffered to as the "front left" and "front right" line sensors are used mainly to detect the black lines to follow throughout the maze and ensure we continue to follow them. The outer 2, reffered to as the "back left" and "back right" line sensors, are used to detect junctions within the maze.     
                            </p>
                            <p>
                                The short range IR sensors are placed on the front and sides of the robot to detect walls in front of, to the right of, or to the left of the robot while it is traversing the maze. The 3 IR treasure sensors are also placed on the front and sides of the robot to detect treasures. Pictured below is our final version of our robot.

                                <center>
                                <a href="#" class="image featured">
                                    <img src="assets/images/final_robot.jpg" alt="" style="width:512px;"/>
                                </a>
                                </center>

                                The inputs to the multiplexer on our robot, as well as the corresponding select signal bits are shown in the table below.

                                <style>
                                table {
                                    border-collapse: collapse;
                                    width: 50%;
                                }

                                td, th {
                                    border: 1px solid #dddddd;
                                    text-align: center;
                                    padding: 8px;
                                }
                                </style>
                                <center>
                                    <table>
                                        <tr>
                                            <th>Select Bits</th>
                                            <th>Input Number</th>
                                            <th>Sensor Output</th>
                                        </tr>
                                        <tr>
                                            <td>000</td>
                                            <td>Y0</td>
                                            <td>Left Wall Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>001</td>
                                            <td>Y1</td>
                                            <td>Front Wall Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>010</td>
                                            <td>Y2</td>
                                            <td>Right Wall Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>011</td>
                                            <td>Y3</td>
                                            <td>Empty</td>
                                        </tr>
                                        <tr>
                                            <td>100</td>
                                            <td>Y4</td>
                                            <td>Left Treasure Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>101</td>
                                            <td>Y5</td>
                                            <td>Front Treasure Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>110</td>
                                            <td>Y6</td>
                                            <td>Right Treasure Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>111</td>
                                            <td>Y7</td>
                                            <td>Empty</td>
                                        </tr>
                                    </table>
                                </center>
                            </p>
                            <p>
                                Towards the end of the semster, as more and more boards and sensors were placed on our robot, we realized we had a weight issue. Our robot's weight was concentrated too far back and would cause the front of our robot to pop up every time it accelerated from a stop. To counteract this, we added washers the front of our robot. In the future we would have liked to clean up this design. If given more time, we would have designed a printed circuit board (PCB) to clean up wiring. This would have allowed us to use just a single level chasis, also taking care of our weight distrubution issue.
                        <header class="style1">
                            <h2>Initialization</h2>
                            </header>
                            <p>
                                Before we begin discussing the details of our algorithm, we will first lay out the variable declarations as well as particular initializations used in the setup section of our code. We kept track of our maze using a 5 by 4 array of one byte characters, maze. Each character corresponds to the information about one square in the maze. We usee maze[current_row][current_column] to index into the array and access the information about a sqare. Each bit in the character represents a certain characteristic of that square as follows:
                                <style>
                                table {
                                    border-collapse: collapse;
                                    width: 50%;
                                }

                                td, th {
                                    border: 1px solid #dddddd;
                                    text-align: center;
                                    padding: 8px;
                                }
                                </style>
                                <center>
                                    <table>
                                        <tr>
                                            <th>bit 7</th>
                                            <th>bit 6</th>
                                            <th>bit 5</th>
                                            <th>bit 4</th>
                                            <th>bit 3</th>
                                            <th>bit 2</th>
                                            <th>bit 1</th>
                                            <th>bit 0</th>
                                        </tr>
                                        <tr>
                                            <td>Treasure bit 1</td>
                                            <td>Treasure bit 0</td>
                                            <td>visited</td>
                                            <td>unreachable</td>
                                            <td>West wall present</td>
                                            <td>South wall present</td>
                                            <td>East wall present</td>
                                            <td>North wall present</td>
                                        </tr>
                                    </table>
                                </center>
                                We defined certain constants so that updating each maze square simply requires bitwise OR-ing with these constants. Those define statements are as follows:
                                <pre><code>
                                #define NORTHWALL 0x01
                                #define SOUTHWALL 0X02
                                #define EASTWALL 0x04
                                #define WESTWALL 0x08
                                #define UNREACHABLE 0x10
                                #define VISITED 0x20
                                #define SEVEN_TREASURE 0x40
                                #define TWELVE_TREASURE 0x80
                                #define SEVENTEEN_TREASURE 0xc0

                                </code></pre><br />
                                In order to keep track of the current direction the robot is facing, we used an enumeration with values north, south, east and west. North corresponds to the direction we place the robot down in originally and the direction is initalized as such. 
                                </p>
                                <p> 
                                    Our algorithm also needs a way to keep a backtrack que whenever the robot reaches a square with no more possible unvisited squares to move to. We use an array of size 20 to store our backtrack que which is comprised of directions to move in if we must backtrack. An int, backtrack_pointer, is ued to index into the correct value in this array. A 5 by 4 array of ints is used mark reachable squares that are still unvisited and is used to tell if when our robot has finished mapping the entire maze. This array is called possible_moves_maze. 
                                </p>
                                <p>
                                    The setup function of our code initialzes all the pins used as well the servos. For the competition, every robot started in the bottom right corner of the maze so the current row and current column were initialzed to 4 and 3 respectively (the row and column values begin at 0). We also initialize maze[4][3] to be visited and to have a south wall, since we know our robot will be starting with a wall directly behind it.
                        <header class="style1">
                            <h2>Algorithm</h2>
                            </header>
                            The main loop of our code begins with a while loop that is only broken out of if a 660 Hz tone is detected by the microphone or the button is pressed. We then update our current node and then move into a while loop that continues to update each node as long as there is a possible move towards an unvisited node or there are still unvisted and reachable nodes in the possible_moves_maze array. Once we've traveled to every reachable node, we transmit a done signal to the base station. The main loop is as follows:
                            <pre><code>
                            void loop() {
                                  // Don't start until tone or button
                                  while (1) {
                                    if(detect_tone()){
                                      break;
                                    }
                                    if (digitalRead(BUTTON) == HIGH) {
                                      break;
                                    }
                                  }
                                  update_node();
                                  //keep updating until done
                                  while (onward() != -1) {
                                    update_node();
                                  }
                                  //Done
                                  while(1){
                                    transmit_node(maze[current_row][current_column], 255,255);
                                  }
                            }
                            </code></pre><br />

                            The detect_tone() function uses the FFT library which outputs values for each bin number. In a previous lab we chose to iterate through 256 bins, but in order to save memory on the arduino, we reudced this amount to 128 bins. By printing out the values of each bin, we found that the 660Hz tone now caused a peak in bin 15. We check if this bin is produces a value over 75 to determine if the tone is being played.

                            <pre><code>
                            bool detect_tone() {
                              //Set the MUX select bits
                              digitalWrite(s0, HIGH);
                              digitalWrite(s1, HIGH);
                              digitalWrite(s2, LOW);
                              cli();
                              //Run the FFT
                                for (int i = 0 ; i < 256 ; i += 2) {
                                  fft_input[i] = analogRead(A0); 
                                  fft_input[i+1] = 0;
                                }
                                fft_window();
                                fft_reorder();
                                fft_run();
                                fft_mag_log();
                                sei();
                              //Check bin 15
                              if (fft_log_out[15]>75) {
                                return true;
                              }
                              return false;
                            }
                            </code></pre><br />


                            The update_node() function checks all the walls around the robot when it is at a junction and updates the corresponding bits in the maze array. The function also checks for treasures and then transmits the fully updated byte of information along with the current row and current column of the robot to the base station.

                            <pre><code>

                            void update_node() {
                            //Update all walls
                              switch(dir) {
                                case(north):
                                  if (left_wall()) { maze[current_row][current_column] |= WESTWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= NORTHWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= EASTWALL; }
                                  break;
                                case(south):
                                  if (left_wall()) { maze[current_row][current_column] |= EASTWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= SOUTHWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= WESTWALL; }
                                  break;
                                case(east):
                                  if (left_wall()) { maze[current_row][current_column] |= NORTHWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= EASTWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= SOUTHWALL; }
                                  break;
                                case(west):
                                  if (left_wall()) { maze[current_row][current_column] |= SOUTHWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= WESTWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= NORTHWALL; }
                                  break;
                              }
                                //Check for treasures
                                int treasure = detect_treasure();
                                treasure = treasure << 6;
                                maze[current_row][current_column] |= treasure;
                                //Send the data to the base station
                                transmit_node(maze[current_row][current_column], current_row, current_column);
                            </code></pre><br />

                            The functions used to detect walls (left_wall(), front_wall(), and right_wall()), all follow the same structure with the only difference being which mux select signals to set high or low. The wall sensors work by sending values betweeon 0 and 1023 with higher numbers corresponding to closer objects being detected. We found that a threshold of 250 worked well for determining if a wall was detected or not. Below is one of the three wall detection functions:
                            <pre><code>
                            bool left_wall() {
                                  digitalWrite(mux_s2, LOW);
                                  digitalWrite(mux_s1, LOW);
                                  digitalWrite(mux_s0, LOW);

                                  int wall = analogRead(mux_pin);
                                  
                                  if (wall>250) {
                                    return true;
                                  }
                                  else {
                                    return false;
                                  }
                                }
                            </code></pre><br />

                            <pre><code>
                            </code></pre><br />
                        <header class="style1">
                            <h2>Moving Functions</h2>
                        </header>
                        <header class="style1">
                            <h2>Unresolved Issues</h2>
                        </header>
                        
                        
                        <p>
                        <center>
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/1ABYLtSU5fY" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                        </center>
                       </p>
                        
                       
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style2">
                    <div class="title">FPGA</div>
                    <section id="intro" class="container">
                        <header class="style1">
                            <h2>Overview of Functionality</h2>
                        </header>
                        
                        <p>
                            The FPGA was the single most important component of our base station. First, it needed to be able to communicate with
                            our base station's Arduino, which would be receiving maze information from our robot via the wireless radios. Second,
                            it needed to act as the driver for the VGA monitor that we needed to display the maze on. The FPGA also acted as the
                            platform upon which our logic to update the VGA display in real-time was stored. Additionally, the FPGA needed to
                            output an audio tune to the speakers to play when the robot finished mapping the maze.
                        </p>
                        
                        <header class="style1">
                            <h2>Communication with Base Station Arduino</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                        <header class="style1">
                            <h2>Driving VGA Monitor</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                        <header class="style1">
                            <h2>Confronting Our Problems</h2>
                        </header>
                        <p>
                            Following Milestone 4, we encountered several issues regarding our FPGA code resulting in random pixelation on the
                            VGA display and incorrect locations being colored in. We were able to initialize and color the starting maze correctly,
                            but when we coded the Arduino to send hard-coded instruction values via SPI the problems surfaced. Our grid was colored
                            by having an always @ (*) block with combinational logic assign colors to many small pixel segments. After consulting a
                            TA, we speculated that our problems were caused by accidentally assigning colors to certain pixels multiple times in
                            the always block. To correct this issue, we decided to implement a state machine in order to separate multiple locations
                            in the code where colors were assigned to pixels. Our state machine had 8 states, and the following list indicates the
                            purpose of each state:
                            <center>
                                    <ul>
                                        <li>State 000 = Done Mapping/Play Audio</li>
                                        <li>State 001 = Parse Incoming Data from Arduino</li>
                                        <li>State 010 = Assign Color to Current Location/Mark Treasure</li>
                                        <li>State 011 = Color West Wall</li>
                                        <li>State 100 = Color East Wall</li>
                                        <li>State 101 = Color South Wall</li>
                                        <li>State 110 = Color North Wall</li>
                                        <li>State 111 = Color Previous Location</li>
                                    </ul>
                            </center>
                        </p>
                        
                        <p>
                            We followed the same grid mapping scheme in Milestone 4 by dividing the entire screen into 10x10 pixel grids with our maze being spanned by 36x45 of these pixel grids
                            for a total area of 360x450 pixels. The actual maze represented by a 4x5 grid would be treated as a 9x11 grid by our FPGA to account for all of the walls in addition to
                            all possible grid spaces. As the final competition neared, we realized the colors we chose to initially color the maze for Milestone 4 utilized Red, Green, and Blue to represent other
                            features of the maze instead of Treasures. Below is a list of the updated color scheme for our maze:
                            <center>
                                    <ul>
                                        <li>Turqoise = Unvisited/unreachable grid space</li>
                                        <li>Yellow = Robot's current position</li>
                                        <li>Purple = Already visited grid space</li>
                                        <li>White = No wall</li>
                                        <li>Black = Wall</li>
                                        <li>Red = 7 kHz treasure at that grid space</li>
                                        <li>Green = 12 kHz treasure at that grid space</li>
                                        <li>Blue = 17 kHz treasure at that grid space</li>
                                    </ul>
                            </center>
                        </p>
                        
                        <header class="style1">
                            <h2>State 000: Initialize/ Reset</h2>
                        </header>
                        
                        <p>
                        To incorporate a state machine effectively, we wanted to have our robot functions synced with the FPGA clock to avoid the possibility of floating values,
                        which likely could have been the reason for the pixelation we were experiencing. State 000 is when we reset of initialize the maze, so we use nested for loops
                        to cycle through every grid position in our entire 36x45 maze to color all node location turqoise for unvisited, the perimeter walls black to indicate the boundaries of the maze,
                        and all interior walls white since we are unsure if there is a wall there or not. We also initialize our xy- position to be at the bottom right of the maze because this is
                        a precondition of the competition. Our last position is then updated to have the xy- position value in binary to represent starting at the bottom right in our data representation scheme
                        before moving onto State 001. 
                        </p>
                        
                         <pre><code class="cpp">
                        always @ (posedge CLOCK_25) begin       // Set always block to posedge CLK 
                            if (reset) begin    // Condition for State 000
		
                            integer i;
                            integer j;
                
                            for (i = 0; i < 37; i=i+1) begin    // Loop through pixel grid
                                for (j = 0; j < 46; j=j+1) begin 
                                
                                    wall_grid[i][j] = 3'b000;   // Color all unvisited turqoise
                                    
                                    if (i%9 == 0) begin         // Color all walls white to start
                                        wall_grid[i][j] = 3'b011; 
                                    end
                                        
                                    if (j%9 == 0) begin         // Color all walls white to start
                                        wall_grid[i][j] = 3'b011;
                                    end
                                    if (i%36 == 0) begin        // Color perimeter walls black
                                        wall_grid[i][j] = 3'b100;
                                    end
                                    if (j%45 == 0) begin        // Color perimeter walls black
                                        wall_grid[i][j] = 3'b100;
                                    end
                                    else begin                  // Close inferred latches
                                        wall_grid[i][j] = wall_grid[i][j];
                                    end
                                end
                            end
                            
                            xpos = 3;                           // Initialize starting at bottom right
                            ypos = 4;
                            state = 3'b001;                     // Next state
                            check = 1'b0;
                            LAST_POS = 16'bxxx10011xxxxxxxx;    // Save last position at bottom right
                            doneaudio = 1'b0;                   // Initialize low to not play audio tone
                        end
                        </code></pre><br />
                        
                        <header class="style1">
                            <h2>State 001: Parse Incoming Data</h2>
                        </header>
                        
                        <p>
                        In this state, we first check if DONE is set to HIGH which would indicate the data is ready to be read from the SPI transfer. The actual data is stored in a 16
                        bit long register titled DOUT. We parse the 16 bits accordingly to the code below.
                        </p>
                        
                        <pre><code class="cpp">
                        else if (DONE == 1'b1 && state == 3'b001) begin
                            CURR_POS = DOUT;                            // Save data
                            donecheck = (CURR_POS[15:13]);              // Signals when robot is done
                            ypos = (CURR_POS[12:10]);
                            xpos = (CURR_POS[9:8]);
                            treasure = CURR_POS[7:6];
                            visited = CURR_POS[5];
                            unreach = CURR_POS[4];
                            wallw = CURR_POS[3];
                            walle = CURR_POS[2];
                            walls = CURR_POS[1];
                            walln = CURR_POS[0];
                            state = 3'b010;                             // Next State
                            
                        end
                        </code></pre><br />
                        
                        <header class="style1">
                            <h2>State 010 = Treasure and Current Location</h2>
                        </header>
                        
                        <p>
                        For this state, we need to convert the 4x5 positions of the maze into a 9x11 format, which we accomplish by using the formula y' = 2y +1.
                        We then check the treasure variable we parsed before to see if there was a treasure in that grid location. Depending on the treasure variable we
                        set the current grid position in the 9x11 data_struc register to the correct color. To color to the grid, we do a series of assign statements to set the
                        corresponding positions in the 36x45 grid to the color mapped by the 9x11 grid by using the formula y' = 9(y-1)/2 + n, where n is an offset for the grid positions.
                        </p>
                        
                        <pre><code class="cpp">
                        else if (state == 3'b010) begin
                            
                            bigy = (ypos << 1) + 1;     // Convert 4x5 positions to 9x11
                            bigx = (xpos << 1) + 1;
                            
                            //Treasure & Current Position
                            if (treasure == 2'b01) begin    // Check if there are treasures
                                data_struc[bigx][bigy] = 3'b101;
                            end
                            else if (treasure == 2'b10) begin
                                data_struc[bigx][bigy] = 3'b110;
                            end
                            else if (treasure == 2'b11) begin
                                data_struc[bigx][bigy] = 3'b111;
                            end
                            else begin
                                data_struc[bigx][bigy] = 3'b001;
                            end
                            
                            //Grid Space!
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+1] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+2] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+3] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+4] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+5] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+6] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+7] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+8] = data_struc[bigx][bigy];
                            
                            // etc...
                        </code></pre><br />
                        
                        <header class="style1">
                            <h2>State 011, 100, 101, 110 = Wall Color</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                        <header class="style1">
                            <h2>State 111 = Done and Audio</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                       <p>
                        <center>
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/urRlNmFFwDs" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                        </center>
                       </p>
                       
                       
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style3">
                    <div class="title">Radio Transmission</div>
                    <section id="intro" class="container">
                        <p>
                            Text here
                        </p>
                        
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style1">
                    <div class="title">Base Station Arduino</div>
                    <section id="intro" class="container">
                        <p>
                            Text here
                        </p>
                        
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style1">
                    <div class="title">Final Competition</div>
                    <section id="intro" class="container">
                        <p>
                            Text here
                        </p>
                        
                        <center>
                        <iframe width="560" height="315" src="https://www.youtube.com/embed/Lgc5FaCjiLQ" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                        </center>
                        
                    </section>
                </div>
        
        </div>
        
        <!-- Scripts -->

            <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/jquery.dropotron.min.js"></script>
            <script src="assets/js/skel.min.js"></script>
            <script src="assets/js/skel-viewport.min.js"></script>
            <script src="assets/js/util.js"></script>
            <!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
            <script src="assets/js/main.js"></script>

    </body>
</html>