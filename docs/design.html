<!DOCTYPE HTML>
<!--
    Escape Velocity by HTML5 UP
    html5up.net | @ajlkn
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
        <title>Overbuilt and Underpaid</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
        <link rel="stylesheet" href="assets/css/main.css" />
        <!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
        <link rel="stylesheet" href="assets/highlight/styles/monokai-sublime.css">
        <script src="assets/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body class="homepage">
        <div id="page-wrapper">

            <!-- Header -->
                <div id="header-wrapper" class="wrapper">
                    <div id="header">

                        <!-- Logo -->
                            <div id="logo">
                                <h1><a href="index.html">Robot Design</a></h1>
                                <p>ECE 3400 Team 2 Fall 2017</p>
                            </div>

                        <!-- Nav -->
                            <nav id="nav">
                                <ul>
                                    <li class="current"><a href="index.html">Home</a></li>
                                    <li>
                                        <a href="#">Labs</a>
                                        <ul>
                                            <li><a href="lab1.html">Lab 1</a></li>
                                            <li><a href="lab2.html">Lab 2</a></li>
                                            <li><a href="lab3.html">Lab 3</a></li>
                                            <li><a href="lab4.html">Lab 4</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <a href="#">Milestones</a>
                                        <ul>
                                            <li><a href="milestone1.html">Milestone 1</a></li>
                                            <li><a href="milestone2.html">Milestone 2</a></li>
                                            <li><a href="milestone3.html">Milestone 3</a></li>
                                            <li><a href="milestone4.html">Milestone 4</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="info.html">Team Info</a></li>
                                    <li><a href="minutes.html">Meeting Minutes</a></li>
                                    <li>
                                        <a href="#">Robot Design & Cost</a>
                                        <ul>
                                            <li><a href="design.html">Robot Design</a></li>
                                            <li><a href="cost.html">Robot Cost</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="ethics.html">Ethics</a></li>
                                </ul>
                            </nav>
                    
                    </div>
                </div>
                
                <div id="intro-wrapper" class="wrapper style3">
                    <div class="title">Introduction</div>
                    <section id="intro" class="container">
                        <header class="style1">
                            <h2>Goal</h2>
                            <p>
                                
                            </p>
                        </header>
                    </section>
                    </div>
                
                <div id="intro-wrapper" class="wrapper style1">
                    <div class="title">Movement</div>
                    <section id="intro" class="container">
                        <header class="style1">
                                <h2>Robot Setup</h2>
                            </header>
                            <p>
                                The final version of our robot included the following components:
                                <center>
                                <ul> 
                                    <li>2 Continous Rotation Servos attached to the two wheels</li>
                                    <li>4 line Sensors </li>
                                    <li>3 short range IR Wall Sensors</li>
                                    <li>3 IR Treasure Sensors</li>
                                    <li>1 Arduino Uno</li>
                                    <li>1 Microphone</li>
                                    <li>1 Eight to One Multiplexer</li>
                                    <li>1 Push Button</li>
                                    <li>1 Radio</li>
                                    <li>1 5V Power Bank</li>

                                </ul>
                                </center>
                                The Arduino is the microcontroller that takes in data from all of the sensors, processes our algorithm and controls the servos that move our robot. The microphone and push button are used to start the robot. Either a specific tone is heard by the microphone or the button is pressed to begin the maze mapping. The multiplexer is used to select between 7 different signals: the 3 wall sensors, the 3 treasure sensors or the microphone. The radio is used to communicate the maze information to the base station which displays the maze. Every sensor, servo and the microcontroller is powered by the power bank.
                                </p>
                                <p>

                                The four line sensors, used to line follow, were placed just a few centimeters above the ground in the front of our robot. Below is a picture of the labeling each of the line sensors.
                                <center>
                                <a href="#" class="image featured">
                                    <img src="assets/images/milestone1_line_sensors.jpg" alt="" style="width:512px;"/>
                                </a>
                                </center>

                                The middle two, reffered to as the "front left" and "front right" line sensors are used mainly to detect the black lines to follow throughout the maze and ensure we continue to follow them. The outer 2, reffered to as the "back left" and "back right" line sensors, are used to detect junctions within the maze.     
                            </p>
                            <p>
                                The short range IR sensors are placed on the front and sides of the robot to detect walls in front of, to the right of, or to the left of the robot while it is traversing the maze. The 3 IR treasure sensors are also placed on the front and sides of the robot to detect treasures. Pictured below is our final version of our robot.

                                <center>
                                <a href="#" class="image featured">
                                    <img src="assets/images/final_robot.jpg" alt="" style="width:512px;"/>
                                </a>
                                </center>

                                The inputs to the multiplexer on our robot, as well as the corresponding select signal bits are shown in the table below.

                                <style>
                                table {
                                    border-collapse: collapse;
                                    width: 50%;
                                }

                                td, th {
                                    border: 1px solid #dddddd;
                                    text-align: center;
                                    padding: 8px;
                                }
                                </style>
                                <center>
                                    <table>
                                        <tr>
                                            <th>Select Bits</th>
                                            <th>Input Number</th>
                                            <th>Sensor Output</th>
                                        </tr>
                                        <tr>
                                            <td>000</td>
                                            <td>Y0</td>
                                            <td>Left Wall Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>001</td>
                                            <td>Y1</td>
                                            <td>Front Wall Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>010</td>
                                            <td>Y2</td>
                                            <td>Right Wall Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>011</td>
                                            <td>Y3</td>
                                            <td>Empty</td>
                                        </tr>
                                        <tr>
                                            <td>100</td>
                                            <td>Y4</td>
                                            <td>Left Treasure Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>101</td>
                                            <td>Y5</td>
                                            <td>Front Treasure Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>110</td>
                                            <td>Y6</td>
                                            <td>Right Treasure Sensor</td>
                                        </tr>
                                        <tr>
                                            <td>111</td>
                                            <td>Y7</td>
                                            <td>Empty</td>
                                        </tr>
                                    </table>
                                </center>
                            </p>
                            <p>
                                Towards the end of the semster, as more and more boards and sensors were placed on our robot, we realized we had a weight issue. Our robot's weight was concentrated too far back and would cause the front of our robot to pop up every time it accelerated from a stop. To counteract this, we added washers the front of our robot. In the future we would have liked to clean up this design. If given more time, we would have designed a printed circuit board (PCB) to clean up wiring. This would have allowed us to use just a single level chasis, also taking care of our weight distrubution issue.
                        <header class="style1">
                            <h2>Initialization</h2>
                            </header>
                            <p>
                                Before we begin discussing the details of our algorithm, we will first lay out the variable declarations as well as particular initializations used in the setup section of our code. We kept track of our maze using a 5 by 4 array of one byte characters, maze. Each character corresponds to the information about one square in the maze. We usee maze[current_row][current_column] to index into the array and access the information about a sqare. Each bit in the character represents a certain characteristic of that square as follows:
                                <style>
                                table {
                                    border-collapse: collapse;
                                    width: 50%;
                                }

                                td, th {
                                    border: 1px solid #dddddd;
                                    text-align: center;
                                    padding: 8px;
                                }
                                </style>
                                <center>
                                    <table>
                                        <tr>
                                            <th>bit 7</th>
                                            <th>bit 6</th>
                                            <th>bit 5</th>
                                            <th>bit 4</th>
                                            <th>bit 3</th>
                                            <th>bit 2</th>
                                            <th>bit 1</th>
                                            <th>bit 0</th>
                                        </tr>
                                        <tr>
                                            <td>Treasure bit 1</td>
                                            <td>Treasure bit 0</td>
                                            <td>visited</td>
                                            <td>unreachable</td>
                                            <td>West wall present</td>
                                            <td>South wall present</td>
                                            <td>East wall present</td>
                                            <td>North wall present</td>
                                        </tr>
                                    </table>
                                </center>
                                We defined certain constants so that updating each maze square simply requires bitwise OR-ing with these constants. Those define statements are as follows:
                                <pre><code>
                                #define NORTHWALL 0x01
                                #define SOUTHWALL 0X02
                                #define EASTWALL 0x04
                                #define WESTWALL 0x08
                                #define UNREACHABLE 0x10
                                #define VISITED 0x20
                                #define SEVEN_TREASURE 0x40
                                #define TWELVE_TREASURE 0x80
                                #define SEVENTEEN_TREASURE 0xc0

                                </code></pre><br />
                                In order to keep track of the current direction the robot is facing, we used an enumeration with values north, south, east and west. North corresponds to the direction we place the robot down in originally and the direction is initalized as such. 
                                </p>
                                <p> 
                                    Our algorithm also needs a way to keep a backtrack que whenever the robot reaches a square with no more possible unvisited squares to move to. We use an array of size 20 to store our backtrack que which is comprised of directions to move in if we must backtrack. An int, backtrack_pointer, is ued to index into the correct value in this array. A 5 by 4 array of ints is used mark reachable squares that are still unvisited and is used to tell if when our robot has finished mapping the entire maze. This array is called possible_moves_maze. 
                                </p>
                                <p>
                                    The setup function of our code initialzes all the pins used as well the servos. For the competition, every robot started in the bottom right corner of the maze so the current row and current column were initialzed to 4 and 3 respectively (the row and column values begin at 0). We also initialize maze[4][3] to be visited and to have a south wall, since we know our robot will be starting with a wall directly behind it.
                        <header class="style1">
                            <h2>Algorithm</h2>
                            </header>
                            The main loop of our code begins with a while loop that is only broken out of if a 660 Hz tone is detected by the microphone or the button is pressed. We then update our current node and then move into a while loop that continues to update each node as long as there is a possible move towards an unvisited node or there are still unvisted and reachable nodes in the possible_moves_maze array. Once we've traveled to every reachable node, we transmit a done signal to the base station. The main loop is as follows:
                            <pre><code>
                            void loop() {
                                  // Don't start until tone or button
                                  while (1) {
                                    if(detect_tone()){
                                      break;
                                    }
                                    if (digitalRead(BUTTON) == HIGH) {
                                      break;
                                    }
                                  }
                                  update_node();
                                  //keep updating until done
                                  while (onward() != -1) {
                                    update_node();
                                  }
                                  //Done
                                  while(1){
                                    transmit_node(maze[current_row][current_column], 255,255);
                                  }
                            }
                            </code></pre><br />

                            The detect_tone() function uses the FFT library which outputs values for each bin number. In a previous lab we chose to iterate through 256 bins, but in order to save memory on the arduino, we reudced this amount to 128 bins. By printing out the values of each bin, we found that the 660Hz tone now caused a peak in bin 15. We check if this bin is produces a value over 75 to determine if the tone is being played.

                            <pre><code>
                            bool detect_tone() {
                              //Set the MUX select bits
                              digitalWrite(s0, HIGH);
                              digitalWrite(s1, HIGH);
                              digitalWrite(s2, LOW);
                              cli();
                              //Run the FFT
                                for (int i = 0 ; i < 256 ; i += 2) {
                                  fft_input[i] = analogRead(A0); 
                                  fft_input[i+1] = 0;
                                }
                                fft_window();
                                fft_reorder();
                                fft_run();
                                fft_mag_log();
                                sei();
                              //Check bin 15
                              if (fft_log_out[15]>75) {
                                return true;
                              }
                              return false;
                            }
                            </code></pre><br />


                            The update_node() function checks all the walls around the robot when it is at a junction and updates the corresponding bits in the maze array. The function also checks for treasures and then transmits the fully updated byte of information along with the current row and current column of the robot to the base station.

                            <pre><code>

                            void update_node() {
                            //Update all walls
                              switch(dir) {
                                case(north):
                                  if (left_wall()) { maze[current_row][current_column] |= WESTWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= NORTHWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= EASTWALL; }
                                  break;
                                case(south):
                                  if (left_wall()) { maze[current_row][current_column] |= EASTWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= SOUTHWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= WESTWALL; }
                                  break;
                                case(east):
                                  if (left_wall()) { maze[current_row][current_column] |= NORTHWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= EASTWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= SOUTHWALL; }
                                  break;
                                case(west):
                                  if (left_wall()) { maze[current_row][current_column] |= SOUTHWALL; }
                                  if (front_wall()) { maze[current_row][current_column] |= WESTWALL; }
                                  if (right_wall()) { maze[current_row][current_column] |= NORTHWALL; }
                                  break;
                              }
                                //Check for treasures
                                int treasure = detect_treasure();
                                treasure = treasure << 6;
                                maze[current_row][current_column] |= treasure;
                                //Send the data to the base station
                                transmit_node(maze[current_row][current_column], current_row, current_column);
                            </code></pre><br />

                            The functions used to detect walls (left_wall(), front_wall(), and right_wall()), all follow the same structure with the only difference being which mux select signals to set high or low. The wall sensors work by sending values betweeon 0 and 1023 with higher numbers corresponding to closer objects being detected. We found that a threshold of 250 worked well for determining if a wall was detected or not. Below is one of the three wall detection functions:
                            <pre><code>
                            bool left_wall() {
                                  digitalWrite(mux_s2, LOW);
                                  digitalWrite(mux_s1, LOW);
                                  digitalWrite(mux_s0, LOW);

                                  int wall = analogRead(mux_pin);
                                  
                                  if (wall>250) {
                                    return true;
                                  }
                                  else {
                                    return false;
                                  }
                                }
                            </code></pre><br />
                            The detect_treasure() function is similar to the detect_tone() function in that it also uses the FFT library. The main difference is that the sampling frequency must be changed since the default is too slow to detect the treasure frequencies of 7kHZ, 12kHz, and 14kHz. In order to speed up the sampling frequency, you must read the value directly from the ADC. The sampling frequency can then be changed by changing the clock prescalar for the ADC clock. By default, the ADC clock is 16 MHz with a default prescalar of 128. Therefore, the ADC clock is 16 MHz/128 = 125 KHz. Since a conversion takes 13 ADC clock cycles, the default sample rate is 125 KHz/13 = 9600 Hz. This sampling rate is not quite fast enough for our purpose, so we adjusted the prescalar to 64 to produce a sampling frequency of approximmately 19.2 KHz. In order to do this, we set the ADPS register to 110. Note, the detect_treasure() function adjusts the ADC clock prescalar as described, but first stores all the changed registers in temporary values so that they can be reset at the end of the function. If we do not do this, we will not be able to use the analogRead() function throughout the rest of our code. Since we also decreased the number of bins from 128 to 256 as we did in the microphone code, we needed to change the bin numbers we checked. Below is an image of the FFT values plotted as a function of bin number when a 12 kHz treasure is present. We used these plots to determine the bin numbers to check for all desired treasure frequencies.

                            <center>
                            <a href="#">
                                <img src="assets/images/IR12khz.png" alt="" style="width:512px;" />
                            </a>
                            </center>

                            The tresure function outputs an int that corresponds to the treasure frequency. Zero corresponds with no treasure, one is 7kHz, two is 12kHz, and 3 is 17kHz. Below is the full detect_treausre() function:
                            <pre><code>
                            int detect_treasure() {
                                  char TIMSK0_temp = TIMSK0;
                                  char ADCSRA_temp = ADCSRA;
                                  char ADMUX_temp = ADMUX;
                                  char DIDR0_temp = DIDR0;
                                  TIMSK0 = 0; // turn off timer0 for lower jitter
                                  ADCSRA = 0xe5; // set the adc to free running mode
                                  ADCSRA &= ~(bit (ADPS0) | bit (ADPS1) | bit (ADPS2)); // clear prescaler bits
                                  ADCSRA |= bit (ADPS0) | bit (ADPS2);
                                  ADMUX = 0x40; // use adc0
                                  DIDR0 = 0x01; // turn off the digital input for adc0
                                  
                                  int treasure = 0;
                                  digitalWrite(s2, HIGH);
                                  //iterate through the different treasure sensors on the mux
                                  for (int i = 0; i < 3; i++) {
                                    digitalWrite(s0, LOW);
                                    digitalWrite(s1, LOW);
                                    if (i & 1) {
                                      digitalWrite(s0, HIGH);
                                    }
                                    if (i & 2) {
                                      digitalWrite(s1, HIGH);
                                    }
                                    cli();  // UDRE interrupt slows this way down on arduino1.0
                                    for (int i = 0 ; i < 256 ; i += 2) { // save 256 samples
                                      while(!(ADCSRA & 0x10)); // wait for adc to be ready
                                      ADCSRA = 0xf5; // restart adc
                                      byte m = ADCL; // fetch adc data
                                      byte j = ADCH;
                                      int k = (j << 8) | m; // form into an int
                                      k -= 0x0200; // form into a signed int
                                      k <<= 6; // form into a 16b signed int
                                      fft_input[i] = k; // put real data into even bins
                                      fft_input[i+1] = 0; // set odd bins to 0
                                    }
                                    fft_window(); // window the data for better frequency response
                                    fft_reorder(); // reorder the data before doing the fft
                                    fft_run(); // process the data in the fft
                                    fft_mag_log(); // take the output of the fft
                                    sei();
                                    
                                    int seven = fft_log_out[24] + fft_log_out[25];
                                    int twelve = fft_log_out[40] + fft_log_out[41] + fft_log_out[42];
                                    int seventeen = fft_log_out[57] + fft_log_out[58] + fft_log_out[59];

                                    //determine if a treasure is present
                                    if (seven > 120){
                                      treasure = 1;
                                    }
                                    else if (twelve > 180){
                                      treasure = 2;
                                    }
                                    else if (seventeen > 180){
                                      treasure = 3;
                                    }
                                  }
                                  //TIMSK0 = TIMSK0_temp;
                                  ADCSRA = ADCSRA_temp;
                                  ADMUX = ADMUX_temp;
                                  DIDR0 = DIDR0_temp;
                                  return treasure;
                                }
                            </code></pre><br />

                            The transmit node function is discussed later on in the radio section. The onward() function other functions to determine if the robot is done or, if not, what the next move should be. Below is the onward() function.

                            <pre><code>
                            int onward() {
                                  int next = next_move();
                                  if (next == north) { move_north(); }
                                  else if (next == south) { move_south(); }
                                  else if (next == east) { move_east(); }
                                  else if (next == west) { move_west(); }
                                  return next;
                                }
                            </code></pre><br />
                            Each of the four possible moving functions (move_north(), move_south(), move_east(), and move_west()) determine, based on the current robot direction, how many left or right turns to make and then move the robot forward until reaching the next junction. Those functions also update the robots direction, the backtrack que, the backtrack pointer and the maze array with the correct values. Below is the function for move_north(). You will notice the opposite direction, south, is added to the backtrack que. This is so that when we are backtracking, we simply have to iterate through the array, moving in the direction that is stored in order to move backwards. 
                            <pre><code>
                            void move_north() {
                                  switch (dir) {
                                    case(north):
                                      move_forward();
                                      break;
                                    case(south):
                                      turn_left();
                                      turn_left();
                                      move_forward();
                                      break;
                                    case(east):
                                      turn_left();
                                      move_forward();
                                      break;
                                    case(west):
                                      turn_right();
                                      move_forward();
                                      break;
                                  }
                                  dir = north;
                                  current_row -= 1;
                                  maze[current_row][current_column] |= VISITED;
                                  possible_moves_maze[current_row][current_column] = 0;
                                  if(backtracking==false){
                                    backtrack_pointer +=1;
                                    backtrack[backtrack_pointer] = south;
                                  }
                                  else{
                                    backtrack_pointer -= 1;
                                  }
                                  backtracking = false;
                                }
                            </code></pre><br />


                            The next_move() function determines which of these functions to call by identifying which directions the robot can move in order to reach an unvisited node that is not blocked by a wall. The possible_moves array stores which direction (north, south, east or west) is a possible move to an unvisited node. Every possible move to an unvisited node is added to the possible_moves array so that we can keep track of when the robot has finished mapping the maze. If there is not a reachable unvisited node, then the last element of possible_moves is set to one to signify that the robot needs to backtrack. 

                            <pre><code>
                            int next_move() {
                                  int possible_moves[5] = {0, 0, 0, 0, 0}; 
                                  int num_moves = 0;
                                  if((!(maze[current_row][current_column] & NORTHWALL)) && (!(maze[current_row-1][current_column] & VISITED))){
                                    possible_moves[north] = 1;
                                    possible_moves_maze[current_row-1][current_column] = 1;
                                    num_moves += 1;
                                  }
                                  if((!(maze[current_row][current_column] & SOUTHWALL)) && (!(maze[current_row+1][current_column] & VISITED))){
                                    possible_moves[south] = 1;
                                    possible_moves_maze[current_row+1][current_column] = 1;
                                    num_moves += 1;
                                  }
                                  if((!(maze[current_row][current_column] & EASTWALL)) && (!(maze[current_row][current_column+1] & VISITED))){
                                    possible_moves[east] = 1;
                                    possible_moves_maze[current_row][current_column+1] = 1;
                                    num_moves += 1;
                                  }
                                  if((!(maze[current_row][current_column] & WESTWALL)) && (!(maze[current_row][current_column-1] & VISITED))){
                                    possible_moves[west] = 1;
                                    possible_moves_maze[current_row][current_column-1] = 1;
                                    num_moves += 1;
                                  }
                                  if (num_moves == 0) {
                                    possible_moves[4] = 1;
                                  }
                                  int next_move = best_move(possible_moves);
                                  return next_move;
                                }
                            </code></pre><br />

                            To determine the best move, the best_move() function first checks if the robot is done mapping the maze. If we need to backtrack but the possible_moves array shows only zeros, then the robot is done. Otherwise, the robot iterates through the backtrack que, moving in the direction stored in the array. If the robot is not backtracking, then we always chose the best move to be in the same direction as the current robot direction if possible. If not then the robot turns right. If the robot can't turn right, it turns around (which should never actually happen since the node behind us should be already visited.) If it doesn't turn around, then it turn lefts.

                            <pre><code>
                            int best_move(int *possible_moves) {
                                  if (possible_moves[4]) {
                                    backtracking = true;
                                    int done = 1;
                                    for (int x = 0; x < 4; x++) {
                                      for (int y = 0; y < 5; y++) {
                                        if ((possible_moves_maze[y][x])) {
                                          done = 0;
                                        }
                                      }
                                    }
                                    if (done) { return -1; }
                                    int next_move = backtrack[backtrack_pointer];
                                    return next_move;
                                  }
                                  switch (dir) {
                                    case(north):
                                      if (possible_moves[north]) { return north; }
                                      else if (possible_moves[east]) { return east; }
                                      else if (possible_moves[west]) { return west; }
                                      else if (possible_moves[south]) { return south; }
                                      break;
                                    case(south):
                                      if (possible_moves[south]) { return south; }
                                      else if (possible_moves[west]) { return west; }
                                      else if (possible_moves[east]) { return east; }
                                      else if (possible_moves[north]) { return north; }
                                      break;
                                    case(east):
                                      if (possible_moves[east]) { return east; }
                                      else if (possible_moves[south]) { return south; }
                                      else if (possible_moves[north]) { return north; }
                                      else if (possible_moves[west]) { return west; }
                                      break;
                                    case(west):
                                      if (possible_moves[west]) { return west; }
                                      else if (possible_moves[north]) { return north; }
                                      else if (possible_moves[south]) { return south; }
                                      else if (possible_moves[east]) { return east; }
                                      break;
                                  }
                                }
                            </code></pre><br />

                            All the above functions make up the core of our algorithm in determining where to go at each junction and keeping track of all relevent information. These functions individually work well, but certain fucntions, such as the detect_tone() and detect_treasure() fucntions experience issues when incorporated into our code. These issues, our methods in attempting to resolve them and how we would fix them in the future is dicussed in the Unresolved Issues section below. 

                            <pre><code>
                            </code></pre><br />
                        <header class="style1">
                            <h2>Moving Functions</h2>
                        </header>
                        <header class="style1">
                            <h2>Unresolved Issues</h2>
                        </header>
                        
                        
                        <p>
                        <center>
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/1ABYLtSU5fY" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                        </center>
                       </p>
                        
                       
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style2">
                    <div class="title">FPGA</div>
                    <section id="intro" class="container">
                        <header class="style1">
                            <h2>Overview of Functionality</h2>
                        </header>
                        
                        <p>
                            The FPGA was the single most important component of our base station. First, it needed to be able to communicate with
                            our base station's Arduino, which would be receiving maze information from our robot via the wireless radios. Second,
                            it needed to act as the driver for the VGA monitor that we needed to display the maze on. The FPGA also acted as the
                            platform upon which our logic to update the VGA display in real-time was stored. Additionally, the FPGA needed to
                            output an audio tune to the speakers to play when the robot finished mapping the maze.
                        </p>
                        
                        <header class="style1">
                            <h2>Communication with Base Station Arduino</h2>
                        </header>
                        
                        <p>
                            As we discussed for Milestone 4, we decided to use the SPI serial communication protocol to facilitate communication
                            between the Base Station Arduino and the FPGA. To recap what was mentioned then, we needed four connection lines
                            between the Arduino and the FPGA: clock (SCK), MOSI (master-out, slave-in), MISO (master-in, slave-out), and
                            slave-select (SS). The SCK, MISO, and MOSI lines were connected to Arduino pins 13, 12, and 11, respectively.
                            We also assigned the SS pin for SPI communication to be digital pin 4 on the Arduino. In order for the Arduino to
                            send data to the FPGA, the SS line needed to be set to low and kept low for the duration of the communication period.
                            Data was sent from the Arduino to the FPGA on the MOSI line. Hence, the Arduino was the master and the FPGA was the
                            slave. Three of the four Arduino pins connected to the FPGA needed to go through a voltage divider first to step the voltage
                            down from 5V (the output voltage of the arduino digital pins) to 3.3V (the input voltage of the GPIO pins on the FPGA)
                            by using 330 Ohm and 680 Ohm resistors. The only line that did not need to go through a voltage divider was the MISO
                            line because its voltage was determined by the GPIO pin on the FPGA that was acting as the output.
                        </p>
                        
                        <p>
                            An important discovery that we made during testing was that the MISO line was disrupting our radio communication
                            between Arduinos. However, the MISO line was technically never used because we only communicated from Arduino to FPGA,
                            never the other way. Therefore, we ended up disconnecting our MISO line altogether, and its interference with the
                            radio communication ended.
                        </p>
                        
                        <p>
                            Below is our sequential logic block from our spi_slave.v module on the FPGA:
                        </p>
                        <pre><code class="cpp">
                        always @(*) begin
                            ss_d = ss;
                            mosi_d = mosi;
                            miso_d = miso_q;
                            sck_d = sck;
                            sck_old_d = sck_q;
                            data_d = data_q;
                            done_d = 1'b0;
                            bit_ct_d = bit_ct_q;
                            dout_d = dout_q;
                             
                            if (ss_q) begin                           // if slave select is high (deselcted)
                              bit_ct_d = 4'b0;                        // reset bit counter
                              data_d = din;                           // read in data
                              miso_d = data_q[15];                     // output MSB
                            end else begin                            // else slave select is low (selected)
                              if (!sck_old_q && sck_q) begin          // rising edge
                                data_d = {data_q[14:0], mosi_q};       // read data in and shift
                                bit_ct_d = bit_ct_q + 1'b1;           // increment the bit counter
                                if (bit_ct_q == 4'b1111) begin         // if we are on the last bit
                                  dout_d = {data_q[14:0], mosi_q};     // output the byte
                                  done_d = 1'b1;                      // set transfer done flag
                                  data_d = din;                       // read in new byte
                                end
                              end else if (sck_old_q && !sck_q) begin // falling edge
                                miso_d = data_q[15];                   // output MSB
                              end
                            end
                        end
                        </code></pre><br />
                        
                        <p>
                            As you can see, new information is only read in when the slave select line is low.
                        </p>
                        
                        <header class="style1">
                            <h2>Driving VGA Monitor</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                        <header class="style1">
                            <h2>Confronting Our Problems</h2>
                        </header>
                        <p>
                            Following Milestone 4, we encountered several issues regarding our FPGA code resulting in random pixelation on the
                            VGA display and incorrect locations being colored in. We were able to initialize and color the starting maze correctly,
                            but when we coded the Arduino to send hard-coded instruction values via SPI the problems surfaced. Our grid was colored
                            by having an always @ (*) block with combinational logic assign colors to many small pixel segments. After consulting a
                            TA, we speculated that our problems were caused by accidentally assigning colors to certain pixels multiple times in
                            the always block. To correct this issue, we decided to implement a state machine in order to separate multiple locations
                            in the code where colors were assigned to pixels. Our state machine had 8 states, and the following list indicates the
                            purpose of each state:
                            <center>
                                    <ul>
                                        <li>State 000 = Done Mapping/Play Audio</li>
                                        <li>State 001 = Parse Incoming Data from Arduino</li>
                                        <li>State 010 = Assign Color to Current Location/Mark Treasure</li>
                                        <li>State 011 = Color West Wall</li>
                                        <li>State 100 = Color East Wall</li>
                                        <li>State 101 = Color South Wall</li>
                                        <li>State 110 = Color North Wall</li>
                                        <li>State 111 = Color Previous Location</li>
                                    </ul>
                            </center>
                        </p>
                        
                        <p>
                            We followed the same grid mapping scheme in Milestone 4 by dividing the entire screen into 10x10 pixel grids with our maze being spanned by 36x45 of these pixel grids
                            for a total area of 360x450 pixels. The actual maze represented by a 4x5 grid would be treated as a 9x11 grid by our FPGA to account for all of the walls in addition to
                            all possible grid spaces. As the final competition neared, we realized the colors we chose to initially color the maze for Milestone 4 utilized Red, Green, and Blue to represent other
                            features of the maze instead of Treasures. Below is a list of the updated color scheme for our maze:
                            <center>
                                    <ul>
                                        <li>Turqoise = Unvisited/unreachable grid space</li>
                                        <li>Yellow = Robot's current position</li>
                                        <li>Purple = Already visited grid space</li>
                                        <li>White = No wall</li>
                                        <li>Black = Wall</li>
                                        <li>Red = 7 kHz treasure at that grid space</li>
                                        <li>Green = 12 kHz treasure at that grid space</li>
                                        <li>Blue = 17 kHz treasure at that grid space</li>
                                    </ul>
                            </center>
                        </p>
                        
                        <header class="style1">
                            <h2>State 000: Initialize/ Reset</h2>
                        </header>
                        
                        <p>
                        To incorporate a state machine effectively, we wanted to have our robot functions synced with the FPGA clock to avoid the possibility of floating values,
                        which likely could have been the reason for the pixelation we were experiencing. State 000 is when we reset of initialize the maze, so we use nested for loops
                        to cycle through every grid position in our entire 36x45 maze to color all node location turqoise for unvisited, the perimeter walls black to indicate the boundaries of the maze,
                        and all interior walls white since we are unsure if there is a wall there or not. We also initialize our xy- position to be at the bottom right of the maze because this is
                        a precondition of the competition. Our last position is then updated to have the xy- position value in binary to represent starting at the bottom right in our data representation scheme
                        before moving onto State 001. 
                        </p>
                        
                        <pre><code class="cpp">
                        always @ (posedge CLOCK_25) begin       // Set always block to posedge CLK 
                            if (reset) begin    // Condition for State 000
		
                            integer i;
                            integer j;
                
                            for (i = 0; i < 37; i=i+1) begin    // Loop through pixel grid
                                for (j = 0; j < 46; j=j+1) begin 
                                
                                    wall_grid[i][j] = 3'b000;   // Color all unvisited turqoise
                                    
                                    if (i%9 == 0) begin         // Color all walls white to start
                                        wall_grid[i][j] = 3'b011; 
                                    end
                                        
                                    if (j%9 == 0) begin         // Color all walls white to start
                                        wall_grid[i][j] = 3'b011;
                                    end
                                    if (i%36 == 0) begin        // Color perimeter walls black
                                        wall_grid[i][j] = 3'b100;
                                    end
                                    if (j%45 == 0) begin        // Color perimeter walls black
                                        wall_grid[i][j] = 3'b100;
                                    end
                                    else begin                  // Close inferred latches
                                        wall_grid[i][j] = wall_grid[i][j];
                                    end
                                end
                            end
                            
                            xpos = 3;                           // Initialize starting at bottom right
                            ypos = 4;
                            state = 3'b001;                     // Next state
                            check = 1'b0;
                            LAST_POS = 16'bxxx10011xxxxxxxx;    // Save last position at bottom right
                            doneaudio = 1'b0;                   // Initialize low to not play audio tone
                        end
                        </code></pre><br />
                        
                        <header class="style1">
                            <h2>State 001: Parse Incoming Data</h2>
                        </header>
                        
                        <p>
                        In this state, we first check if DONE is set to HIGH which would indicate the data is ready to be read from the SPI transfer. The actual data is stored in a 16
                        bit long register titled DOUT. We parse the 16 bits accordingly to the code below.
                        </p>
                        
                        <pre><code class="cpp">
                        else if (DONE == 1'b1 && state == 3'b001) begin
                            CURR_POS = DOUT;                            // Save data
                            donecheck = (CURR_POS[15:13]);              // Signals when robot is done
                            ypos = (CURR_POS[12:10]);
                            xpos = (CURR_POS[9:8]);
                            treasure = CURR_POS[7:6];
                            visited = CURR_POS[5];
                            unreach = CURR_POS[4];
                            wallw = CURR_POS[3];
                            walle = CURR_POS[2];
                            walls = CURR_POS[1];
                            walln = CURR_POS[0];
                            state = 3'b010;                             // Next State
                            
                        end
                        </code></pre><br />
                        
                        <header class="style1">
                            <h2>State 010 = Treasure and Current Location</h2>
                        </header>
                        
                        <p>
                        For this state, we need to convert the 4x5 positions of the maze into a 9x11 format, which we accomplish by using the formula y' = 2y +1.
                        We then check the treasure variable we parsed before to see if there was a treasure in that grid location. Depending on the treasure variable we
                        set the current grid position in the 9x11 data_struc register to the correct color. To color to the grid, we do a series of assign statements to set the
                        corresponding positions in the 36x45 grid to the color mapped by the 9x11 grid by using the formula y' = 9(y-1)/2 + n, where n is an offset for the grid positions.
                        </p>
                        
                        <pre><code class="cpp">
                        else if (state == 3'b010) begin
                            
                            bigy = (ypos << 1) + 1;     // Convert 4x5 positions to 9x11
                            bigx = (xpos << 1) + 1;
                            
                            //Treasure & Current Position
                            if (treasure == 2'b01) begin    // Check if there are treasures
                                data_struc[bigx][bigy] = 3'b101;
                            end
                            else if (treasure == 2'b10) begin
                                data_struc[bigx][bigy] = 3'b110;
                            end
                            else if (treasure == 2'b11) begin
                                data_struc[bigx][bigy] = 3'b111;
                            end
                            else begin
                                data_struc[bigx][bigy] = 3'b001;
                            end
                            
                            //Grid Space!
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+1] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+2] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+3] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+4] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+5] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+6] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+7] = data_struc[bigx][bigy];
                            wall_grid[(9*((bigx-1)>> 1))+1][(9*((bigy-1)>> 1))+8] = data_struc[bigx][bigy];
                            
                            // etc...
                        </code></pre><br />
                        
                        <header class="style1">
                            <h2>State 011, 100, 101, 110 = Wall Color</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                        <header class="style1">
                            <h2>State 111 = Done and Audio</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                       <p>
                        <center>
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/urRlNmFFwDs" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                        </center>
                       </p>
                       
                       
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style3">
                    <div class="title">Radio Transmission</div>
                    <section id="intro" class="container">
                        <p>
                        Our radio transmission followed the same data structure with the first byte characterizing the features regarding the grid space, and the second byte describing the robot location.
                        The only addition to our Milestone 4 scheme was to change the three previusly unused bits in the second byte to indicate when the robot has finished completing the maze via DFS.
                        When the robot completes the maze, these bits will be set to 3'b111.
                        </p>
                        
                        <center>
		                            <table>
		                                <tr>
		                                    <th>bit 7</th>
		                                    <th>bit 6</th>
		                                    <th>bit 5</th>
		                                    <th>bit 4</th>
		                                    <th>bit 3</th>
		                                    <th>bit 2</th>
		                                    <th>bit 1</th>
		                                    <th>bit 0</th>
		                                </tr>
		                                <tr>
		                                    <td>Treasure bit 1</td>
		                                    <td>Treasure bit 0</td>
		                                    <td>visited</td>
		                                    <td>unreachable</td>
		                                    <td>West wall present</td>
		                                    <td>South wall present</td>
		                                    <td>East wall present</td>
		                                    <td>North wall present</td>
		                                </tr>
		                            </table>
		                        </center>
                        <center>
		                            <table>
		                                <tr>
		                                    <th>bit 7</th>
		                                    <th>bit 6</th>
		                                    <th>bit 5</th>
		                                    <th>bit 4</th>
		                                    <th>bit 3</th>
		                                    <th>bit 2</th>
		                                    <th>bit 1</th>
		                                    <th>bit 0</th>
		                                </tr>
		                                <tr>
		                                    <td>Done bit 2</td>
		                                    <td>Done bit 1</td>
		                                    <td>Done bit 0</td>
		                                    <td>Row bit 2 </td>
		                                    <td>Row bit 1</td>
		                                    <td>Row bit 0</td>
		                                    <td>Column bit 1</td>
		                                    <td>Column bit 0</td>
		                                </tr>
		                            </table>
		                        </center>
                        
                        <header class="style1">
                            <h2>Robot Transmission</h2>
                        </header>
                        
                        <p>
                        In order for the robot to communicate with the base station Arduino, we utilized two Nordic nRF24L01 along with the RF24 Arduino library and "Getting Started" sketch within the library.
                        We initialize the Arduino pins 9 and 10 with 9 being the data line between the Arduino and FPGA, while pin 10 is the SS for the SPI transfer bus. Our radios were set to transmit and receive
                        on channels 4 and 5 by use of the formula 2(3D + N) + X where D is our lab data (Monday = 0), N is our team number (Team 2 = 2), and X is either 0 or 1 to identify the two radios. Since our radio
                        transmission involves sending two bytes of data, we set the payload size to 2. There are two pipes set to allow for reading and writing with respect to the transmitting and receiving radios. 
                        
                        
                        </p>
                        
                        <pre><code class="cpp">
                        #include "radio.h"                      
                        // Hardware configuration
                        
                        RF24 radio(9,10);               // Set up nRF24L01 radio on SPI bus plus pins 9 & 10
            
                        // Radio pipe addresses for the 2 nodes to communicate.
                        const uint64_t pipes[2] = { 0x0000000004LL, 0x0000000005LL }; // Team #2 Address is 4 and 5
                    
                        void radio_setup(void)
                        {
                          radio.setPayloadSize(2);          // 2 byte payload
                        
                          radio.begin();                    // Setup and configure rf radio
                        
                          // optionally, increase the delay between retries & # of retries
                          radio.setRetries(15,15);
                          radio.setAutoAck(true);
                          radio.setChannel(0x50);           // Set the channel
                          // RF24_PA_MIN=-18dBm, RF24_PA_LOW=-12dBm, RF24_PA_MED=-6dBM, and RF24_PA_HIGH=0dBm.
                          radio.setPALevel(RF24_PA_MIN);    // Set the power
                          //RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps
                          radio.setDataRate(RF24_250KBPS);
            
                          // Open 'our' pipe for writing
                          // Open the 'other' pipe for reading, in position #1 (we can have up to 5 pipes open for reading)
                          radio.openWritingPipe(pipes[0]);
                          radio.openReadingPipe(1,pipes[1]);
              
                          radio.startListening();           // Start listening

                        </code></pre><br />
                        
                        <p>
                        
                        </p>
                        
                        <pre><code class="cpp">
                        bool transmit_node(char node, int row, int column){
                            char data_buffer[2];        // Initilize 2 bytes of data
                            row = row<<2;               // Shift row by 2 places     
                            char coords = row | column; // OR row and column positions
                            data_buffer[1] = node;      
                            data_buffer[0] = coords;
                            Serial.println("data to send");
                            Serial.println( data_buffer[0]);
                            Serial.println( data_buffer[1]);
                        </code></pre><br />
                        
                        
                        
                        
                        <header class="style1">
                            <h2>Base Station Receive</h2>
                        </header>
                        
                        <p>
                            
                        </p>
                        
                        
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style1">
                    <div class="title">Base Station Arduino</div>
                    <section id="intro" class="container">
                        <p>
                            Text here
                        </p>
                        
                    </section>
                </div>
                
                <div id="intro-wrapper" class="wrapper style2">
                    <div class="title">Final Competition</div>
                    <section id="intro" class="container">
                        <p>
                            Text here
                        </p>
                        
                        <center>
                        <iframe width="560" height="315" src="https://www.youtube.com/embed/Lgc5FaCjiLQ" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                        </center>
                        
                    </section>
                </div>
        
        </div>
        
        <!-- Scripts -->

            <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/jquery.dropotron.min.js"></script>
            <script src="assets/js/skel.min.js"></script>
            <script src="assets/js/skel-viewport.min.js"></script>
            <script src="assets/js/util.js"></script>
            <!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
            <script src="assets/js/main.js"></script>

    </body>
</html>